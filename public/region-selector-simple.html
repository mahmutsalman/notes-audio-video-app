<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Region Selector</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-color: rgba(0, 0, 0, 0.3);
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      cursor: crosshair;
      font-family: system-ui, -apple-system, sans-serif;
    }

    #instructions {
      position: absolute;
      top: 32px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 24px 48px;
      border-radius: 12px;
      text-align: center;
      pointer-events: none;
      z-index: 1000;
    }

    #instructions h2 {
      font-size: 20px;
      margin-bottom: 8px;
    }

    #instructions p {
      font-size: 14px;
      opacity: 0.8;
    }

    #rectangle {
      position: absolute;
      border: 2px solid #3b82f6;
      background: rgba(59, 130, 246, 0.1);
      display: none;
      pointer-events: none;
    }

    #dimensions {
      position: absolute;
      background: rgba(0, 0, 0, 0.75);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 13px;
      font-family: monospace;
      display: none;
      pointer-events: none;
      z-index: 1001;
    }

    #startButton {
      width: 28px;
      height: 28px;
      min-width: 28px;
      min-height: 28px;
      background: #dc2626 !important;
      border: none;
      border-radius: 50%;
      cursor: pointer;
      display: inline-block !important;
      box-shadow: 0 2px 6px rgba(220, 38, 38, 0.4);
      transition: all 0.2s;
      pointer-events: auto;
      margin: 0;
      flex-shrink: 0;
      position: relative;
      opacity: 1 !important;
      visibility: visible !important;
    }

    #startButton::before {
      content: '';
      position: absolute;
      width: 10px;
      height: 10px;
      background: white;
      border-radius: 50%;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    #startButton:hover {
      background: #b91c1c !important;
      transform: scale(1.1);
      box-shadow: 0 6px 16px rgba(220, 38, 38, 0.8);
    }

    #stopButton {
      position: absolute;
      background: #dc2626;
      color: white;
      border: none;
      padding: 12px 32px;
      border-radius: 8px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      display: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      transition: background 0.2s;
      z-index: 1002;
      pointer-events: auto;
    }

    #stopButton:hover {
      background: #b91c1c;
    }

    #recordingIndicator {
      position: absolute;
      background: rgba(220, 38, 38, 0.9);
      color: white;
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 600;
      display: none;
      z-index: 1001;
      pointer-events: none;
    }

    #recordingIndicator::before {
      content: '●';
      display: inline-block;
      margin-right: 8px;
      animation: blink 1s infinite;
    }

    @keyframes blink {
      0%, 50% { opacity: 1; }
      51%, 100% { opacity: 0.3; }
    }

    /* Control Panel Styles (CleanShot X Aesthetic - Compact & Stacked) */
    #controlPanel {
      position: absolute;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      border-radius: 10px;
      padding: 8px;
      display: none;
      flex-direction: column;
      gap: 4px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
      border: 1px solid rgba(255, 255, 255, 0.1);
      z-index: 1001;
      pointer-events: auto;
      min-width: 200px;
      max-width: 250px;
    }

    .control-group {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 6px 8px;
      border-radius: 6px;
      background: rgba(255, 255, 255, 0.05);
      transition: background 0.2s;
    }

    .control-group:hover {
      background: rgba(255, 255, 255, 0.08);
    }

    .icon-button {
      width: 28px;
      height: 28px;
      background: transparent;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      padding: 0;
      flex-shrink: 0;
    }

    .icon-button:hover:not(.disabled) {
      background: rgba(255, 255, 255, 0.1);
    }

    .icon-button.active {
      background: #3b82f6;
    }

    .icon-button.disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    .icon-button svg {
      width: 16px;
      height: 16px;
      fill: currentColor;
    }

    .device-select, .preset-select {
      background: rgba(255, 255, 255, 0.08);
      color: white;
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 5px;
      padding: 5px 8px;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      flex: 1;
      min-width: 0;
    }

    .device-select:focus, .preset-select:focus {
      border-color: #3b82f6;
      background: rgba(59, 130, 246, 0.1);
    }

    .device-select option, .preset-select option {
      background: #1c1c1e;
      color: white;
    }

    #audioStatus {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.8);
      white-space: nowrap;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    /* Compact grid for quality/FPS */
    .settings-row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4px;
    }

    /* Recording Controls Container */
    #recordingControls {
      position: absolute;
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 1002;
      pointer-events: auto;
    }

    /* Duration Display */
    #durationDisplay {
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 18px;
      font-weight: 600;
      font-family: -apple-system, BlinkMacSystemFont, 'SF Mono', monospace;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
      min-width: 80px;
      text-align: center;
      pointer-events: none;
    }

    /* Button Group */
    #buttonGroup {
      display: flex;
      gap: 8px;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      padding: 8px;
      border-radius: 10px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }

    /* Control Buttons */
    .control-button {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: none;
      border-radius: 8px;
      cursor: pointer;
      transition: all 0.2s;
      display: flex;
      align-items: center;
      justify-content: center;
      color: white;
      font-size: 20px;
      pointer-events: auto;
    }

    .control-button:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
    }

    .control-button:active {
      transform: scale(0.95);
    }

    #stopButtonNew:hover {
      background: rgba(220, 38, 38, 0.9);
    }

    /* Duration Mark Input Field (bottom of screen) */
    #durationMarkInput {
      position: fixed;
      bottom: 40px;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 8px;
      z-index: 1003;
      pointer-events: auto;
    }

    #markingIndicator {
      background: rgba(59, 130, 246, 0.95);
      color: white;
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 12px;
      font-weight: 500;
    }

    #markNoteInput {
      width: 400px;
      padding: 10px 16px;
      font-size: 14px;
      border: 2px solid rgba(59, 130, 246, 0.8);
      border-radius: 8px;
      background: rgba(28, 28, 30, 0.95);
      backdrop-filter: blur(20px);
      -webkit-backdrop-filter: blur(20px);
      color: white;
      outline: none;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
    }

    #markNoteInput:focus {
      border-color: #3b82f6;
      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);
    }

    #markNoteInput::placeholder {
      color: rgba(255, 255, 255, 0.5);
    }
  </style>
</head>
<body>
  <div id="instructions">
    <h2>Click and drag to select a region</h2>
    <p>Press ESC to cancel</p>
  </div>

  <div id="rectangle"></div>
  <div id="dimensions"></div>

  <!-- Control Panel (CleanShot X Style - Compact & Stacked) -->
  <div id="controlPanel">
    <!-- Microphone Row -->
    <div class="control-group">
      <button id="micToggle" class="icon-button" title="Toggle Microphone">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M12 14c1.66 0 3-1.34 3-3V5c0-1.66-1.34-3-3-3S9 3.34 9 5v6c0 1.66 1.34 3 3 3z"/>
          <path d="M17 11c0 2.76-2.24 5-5 5s-5-2.24-5-5H5c0 3.53 2.61 6.43 6 6.92V21h2v-3.08c3.39-.49 6-3.39 6-6.92h-2z"/>
        </svg>
      </button>
      <select id="micSelect" class="device-select">
        <option value="">Microphone</option>
      </select>
    </div>

    <!-- Microphone Level Indicator -->
    <div id="levelIndicatorGroup" class="control-group" style="display: none;">
      <span style="font-size: 11px; color: rgba(255, 255, 255, 0.6); width: 45px; white-space: nowrap;">Level:</span>
      <div style="flex: 1; height: 6px; background: rgba(0, 0, 0, 0.4); border-radius: 3px; overflow: hidden; position: relative;">
        <div id="levelBar" style="height: 100%; background: linear-gradient(to right, #22c55e 0%, #22c55e 60%, #eab308 60%, #eab308 80%, #ef4444 80%); width: 0%; transition: width 0.05s ease; border-radius: 3px;"></div>
      </div>
    </div>

    <!-- Desktop Audio Row -->
    <div class="control-group">
      <button id="audioToggle" class="icon-button disabled" title="Toggle Desktop Audio">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
          <path d="M3 9v6h4l5 5V4L7 9H3zm13.5 3c0-1.77-1.02-3.29-2.5-4.03v8.05c1.48-.73 2.5-2.25 2.5-4.02zM14 3.23v2.06c2.89.86 5 3.54 5 6.71s-2.11 5.85-5 6.71v2.06c4.01-.91 7-4.49 7-8.77s-2.99-7.86-7-8.77z"/>
        </svg>
      </button>
      <span id="audioStatus">Desktop</span>
    </div>

    <!-- Quality & FPS Row (Grid) -->
    <div class="settings-row">
      <select id="qualitySelect" class="preset-select" title="Video Quality">
        <option value="480p">480p</option>
        <option value="720p">720p</option>
        <option value="1080p">1080p</option>
      </select>

      <select id="fpsSelect" class="preset-select" title="Frame Rate">
        <option value="10">10 FPS</option>
        <option value="30">30 FPS</option>
        <option value="60">60 FPS</option>
      </select>
    </div>

    <!-- Start Recording Button Row -->
    <div class="control-group" style="justify-content: center; padding: 8px;">
      <button id="startButton"></button>
    </div>
  </div>
  <button id="stopButton">Stop Recording</button>
  <div id="recordingIndicator">Recording</div>

  <!-- Recording Controls (Duration + Pause/Stop Buttons) -->
  <div id="recordingControls" style="display: none;">
    <div id="durationDisplay">00:00</div>
    <div id="buttonGroup">
      <button id="pauseButton" class="control-button">⏸</button>
      <button id="stopButtonNew" class="control-button">⏹</button>
    </div>
  </div>

  <!-- Duration Mark Input Field (bottom of screen) -->
  <div id="durationMarkInput" style="display: none;">
    <div id="markingIndicator">
      <span>Marking from <span id="markStartTime">0:00</span>...</span>
    </div>
    <input
      id="markNoteInput"
      type="text"
      placeholder="Type a note (optional) - Press Enter to end mark"
    />
  </div>

  <script>
    console.log('[RegionSelector] Simple overlay loaded - VERSION 3.0 WITH CONTROL PANEL');

    let displayInfo = null;
    let currentDisplayId = null; // This overlay's display ID
    let isDrawing = false;
    let startX = 0;
    let startY = 0;
    let rect = null;
    let isRecording = false;
    let clickThroughEnabled = false;

    // Audio and quality settings
    let audioDevices = [];
    let selectedMicId = null;
    let micEnabled = false;
    let desktopAudioEnabled = false;
    let hasBlackHole = false;

    // Microphone level monitoring
    let monitoringStream = null;
    let audioContext = null;
    let analyser = null;
    let animationFrameId = null;
    let isMonitoring = false;

    // Duration mark state
    let isMarking = false;
    let markStartTime = 0;
    let markNoteText = '';

    const rectangleEl = document.getElementById('rectangle');
    const dimensionsEl = document.getElementById('dimensions');
    const startButton = document.getElementById('startButton');
    const stopButton = document.getElementById('stopButton');
    const recordingIndicator = document.getElementById('recordingIndicator');

    // Recording controls elements
    const recordingControls = document.getElementById('recordingControls');
    const durationDisplay = document.getElementById('durationDisplay');
    const pauseButton = document.getElementById('pauseButton');
    const stopButtonNew = document.getElementById('stopButtonNew');
    let isPaused = false;

    // Format duration helper (MM:SS)
    function formatDuration(seconds) {
      const mins = Math.floor(seconds / 60);
      const secs = seconds % 60;
      return `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    // Duration mark helper functions
    function showMarkInput() {
      const inputField = document.getElementById('durationMarkInput');
      const noteInput = document.getElementById('markNoteInput');

      // Lower window to 'floating' to accept keyboard
      console.log('[RegionSelector] Lowering window level to floating for keyboard input');
      window.electronAPI.region.setWindowLevel('floating');

      inputField.style.display = 'flex';
      noteInput.value = markNoteText;

      // Focus after level change processed
      setTimeout(() => {
        noteInput.focus();
        console.log('[RegionSelector] Input field focused and ready for typing');
      }, 100);
    }

    function hideMarkInput() {
      document.getElementById('durationMarkInput').style.display = 'none';
      markNoteText = '';

      // Restore screen-saver level to stay above everything
      console.log('[RegionSelector] Restoring window level to screen-saver');
      window.electronAPI.region.setWindowLevel('screen-saver');
    }

    function updateMarkingIndicator(startSeconds) {
      const mins = Math.floor(startSeconds / 60);
      const secs = startSeconds % 60;
      document.getElementById('markStartTime').textContent =
        `${mins}:${secs.toString().padStart(2, '0')}`;
    }

    const instructions = document.getElementById('instructions');
    const controlPanel = document.getElementById('controlPanel');

    // Position constants for intelligent control placement
    const POSITION_CONSTANTS = {
      PANEL_HEIGHT: 168,        // Control panel height (includes integrated button)
      PANEL_WIDTH: 220,         // Control panel width
      GAP_RECTANGLE: 12,        // Gap between rectangle and controls
      MARGIN_SCREEN: 10         // Minimum margin from screen edges
    };

    // Helper: Select best position based on available space
    function selectBestPosition(spaceBelow, spaceAbove, spaceRight, spaceLeft) {
      const { PANEL_HEIGHT, PANEL_WIDTH, GAP_RECTANGLE } = POSITION_CONSTANTS;

      // Priority 1: Below (default)
      if (spaceBelow >= PANEL_HEIGHT + GAP_RECTANGLE) {
        return 'below';
      }

      // Priority 2: Above
      if (spaceAbove >= PANEL_HEIGHT + GAP_RECTANGLE) {
        return 'above';
      }

      // Priority 3: Right
      if (spaceRight >= PANEL_WIDTH + GAP_RECTANGLE) {
        return 'right';
      }

      // Priority 4: Left
      if (spaceLeft >= PANEL_WIDTH + GAP_RECTANGLE) {
        return 'left';
      }

      // Fallback: Force below with bounds adjustment
      console.warn('[RegionSelector] No adequate space found, forcing below with bounds adjustment');
      return 'below-forced';
    }

    // Helper: Calculate coordinates based on selected position
    function calculatePosition(position) {
      const { PANEL_HEIGHT, PANEL_WIDTH, GAP_RECTANGLE, MARGIN_SCREEN } = POSITION_CONSTANTS;

      let panelLeft, panelTop;

      switch (position) {
        case 'below':
          // Center horizontally, positioned below rectangle
          panelLeft = rect.x + (rect.width / 2) - (PANEL_WIDTH / 2);
          panelTop = rect.y + rect.height + GAP_RECTANGLE;
          break;

        case 'above':
          // Center horizontally, positioned above rectangle
          panelLeft = rect.x + (rect.width / 2) - (PANEL_WIDTH / 2);
          panelTop = rect.y - PANEL_HEIGHT - GAP_RECTANGLE;
          break;

        case 'right':
          // Positioned to right, vertically centered relative to rectangle
          panelLeft = rect.x + rect.width + GAP_RECTANGLE;
          panelTop = rect.y + (rect.height / 2) - (PANEL_HEIGHT / 2);
          break;

        case 'left':
          // Positioned to left, vertically centered relative to rectangle
          panelLeft = rect.x - PANEL_WIDTH - GAP_RECTANGLE;
          panelTop = rect.y + (rect.height / 2) - (PANEL_HEIGHT / 2);
          break;

        case 'below-forced':
          // Force below with aggressive bounds checking
          panelLeft = rect.x + (rect.width / 2) - (PANEL_WIDTH / 2);
          panelTop = Math.min(
            rect.y + rect.height + GAP_RECTANGLE,
            window.innerHeight - PANEL_HEIGHT - MARGIN_SCREEN
          );
          break;
      }

      // Apply horizontal bounds checking for all positions
      panelLeft = Math.max(MARGIN_SCREEN, Math.min(panelLeft, window.innerWidth - PANEL_WIDTH - MARGIN_SCREEN));

      // Apply vertical bounds checking
      panelTop = Math.max(MARGIN_SCREEN, Math.min(panelTop, window.innerHeight - PANEL_HEIGHT - MARGIN_SCREEN));

      return {
        panel: { left: panelLeft, top: panelTop }
      };
    }

    // Helper: Apply calculated position to DOM elements
    function applyPosition(coords) {
      // Position control panel
      controlPanel.style.left = coords.panel.left + 'px';
      controlPanel.style.top = coords.panel.top + 'px';
      controlPanel.style.display = 'flex';

      console.log('[RegionSelector] Control panel positioned at:', coords.panel);
      console.log('[RegionSelector] Panel actual height:', controlPanel.offsetHeight);
    }

    // Position control panel with intelligent fallback (below → above → right → left)
    function positionControlPanel() {
      console.log('[RegionSelector] Positioning control panel with intelligent fallback');

      const { PANEL_HEIGHT, PANEL_WIDTH, GAP_RECTANGLE, MARGIN_SCREEN } = POSITION_CONSTANTS;

      // Calculate available space in each direction
      const spaceBelow = window.innerHeight - (rect.y + rect.height) - MARGIN_SCREEN;
      const spaceAbove = rect.y - MARGIN_SCREEN;
      const spaceRight = window.innerWidth - (rect.x + rect.width) - MARGIN_SCREEN;
      const spaceLeft = rect.x - MARGIN_SCREEN;

      console.log('[RegionSelector] Available space:', {
        below: spaceBelow,
        above: spaceAbove,
        right: spaceRight,
        left: spaceLeft
      });

      // Position selection with priority: Below → Above → Right → Left
      const position = selectBestPosition(spaceBelow, spaceAbove, spaceRight, spaceLeft);

      console.log('[RegionSelector] Selected position:', position);

      // Apply positioning based on selected direction
      const coords = calculatePosition(position);
      applyPosition(coords);
    }

    // Enumerate audio devices and populate microphone selector
    async function loadAudioDevices() {
      console.log('[RegionSelector] Loading audio devices');
      try {
        // Request permission first (required for device labels)
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        stream.getTracks().forEach(track => track.stop());

        const devices = await navigator.mediaDevices.enumerateDevices();
        audioDevices = devices.filter(d => d.kind === 'audioinput');

        console.log('[RegionSelector] Found', audioDevices.length, 'audio input devices');

        // Populate mic select
        const micSelect = document.getElementById('micSelect');
        micSelect.innerHTML = '<option value="">Select Microphone...</option>';

        audioDevices.forEach(device => {
          const option = document.createElement('option');
          option.value = device.deviceId;
          option.textContent = device.label || `Microphone ${device.deviceId.slice(0, 5)}`;
          micSelect.appendChild(option);
        });

        // Check for BlackHole
        hasBlackHole = audioDevices.some(d =>
          d.label.toLowerCase().includes('blackhole')
        );

        console.log('[RegionSelector] BlackHole detected:', hasBlackHole);
        updateDesktopAudioButton();
      } catch (error) {
        console.error('[RegionSelector] Failed to load audio devices:', error);
        // Permission denied or error - disable audio features gracefully
        const micSelect = document.getElementById('micSelect');
        micSelect.innerHTML = '<option value="">Microphone permission denied</option>';
        micSelect.disabled = true;
        document.getElementById('micToggle').classList.add('disabled');
      }
    }

    // Update desktop audio button based on BlackHole detection
    function updateDesktopAudioButton() {
      const audioToggle = document.getElementById('audioToggle');
      const audioStatus = document.getElementById('audioStatus');

      if (hasBlackHole) {
        audioToggle.classList.remove('disabled');
        audioStatus.textContent = 'Desktop';
        audioToggle.title = 'Toggle Desktop Audio';
        console.log('[RegionSelector] Desktop audio available');
      } else {
        audioToggle.classList.add('disabled');
        audioStatus.textContent = 'Desktop';
        audioToggle.title = 'Install BlackHole 2ch to capture desktop audio\n\nVisit: https://existential.audio/blackhole/';
        console.log('[RegionSelector] Desktop audio unavailable (BlackHole not detected)');
      }
    }

    // Start monitoring microphone input levels
    async function startMicrophoneMonitoring() {
      console.log('[RegionSelector] Starting microphone monitoring');

      // Don't start if already monitoring or mic is disabled
      if (isMonitoring || !micEnabled || !selectedMicId) {
        return;
      }

      try {
        // Create monitoring stream (separate from recording stream)
        monitoringStream = await navigator.mediaDevices.getUserMedia({
          audio: {
            deviceId: { exact: selectedMicId },
            echoCancellation: false,  // Disable for accurate level reading
            noiseSuppression: false,
            autoGainControl: false,   // Disable to get raw input levels
            sampleRate: 48000
          }
        });

        // Setup Web Audio API for level analysis
        audioContext = new AudioContext();
        const source = audioContext.createMediaStreamSource(monitoringStream);
        analyser = audioContext.createAnalyser();
        analyser.fftSize = 512;  // 512 samples = good balance
        analyser.smoothingTimeConstant = 0.8;  // Smooth out rapid changes
        source.connect(analyser);

        // Start level monitoring loop
        isMonitoring = true;
        document.getElementById('levelIndicatorGroup').style.display = 'flex';
        updateLevelMeter();

        console.log('[RegionSelector] Microphone monitoring started');
      } catch (error) {
        console.error('[RegionSelector] Failed to start microphone monitoring:', error);
        stopMicrophoneMonitoring();
      }
    }

    // Stop monitoring microphone input levels
    function stopMicrophoneMonitoring() {
      console.log('[RegionSelector] Stopping microphone monitoring');

      isMonitoring = false;

      // Cancel animation frame
      if (animationFrameId) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }

      // Stop monitoring stream
      if (monitoringStream) {
        monitoringStream.getTracks().forEach(track => track.stop());
        monitoringStream = null;
      }

      // Close audio context
      if (audioContext) {
        audioContext.close();
        audioContext = null;
      }

      analyser = null;

      // Hide level indicator and reset bar
      const levelIndicatorGroup = document.getElementById('levelIndicatorGroup');
      const levelBar = document.getElementById('levelBar');
      if (levelIndicatorGroup) levelIndicatorGroup.style.display = 'none';
      if (levelBar) levelBar.style.width = '0%';

      console.log('[RegionSelector] Microphone monitoring stopped');
    }

    // Update level meter visualization (60fps animation loop)
    function updateLevelMeter() {
      if (!isMonitoring || !analyser) {
        return;
      }

      // Get audio frequency data
      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      // Calculate average level (0-255)
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length;

      // Convert to percentage (0-100%)
      // Apply logarithmic scaling for better visual representation
      const normalizedLevel = (average / 255) * 100;
      const scaledLevel = Math.min(100, normalizedLevel * 3.0); // Amplify for better visibility

      // Update level bar width
      const levelBar = document.getElementById('levelBar');
      if (levelBar) {
        levelBar.style.width = scaledLevel + '%';
      }

      // Continue animation loop
      animationFrameId = requestAnimationFrame(updateLevelMeter);
    }

    // Load saved settings from Electron (Phase 6)
    async function loadSettings() {
      console.log('[RegionSelector] Loading saved settings');
      try {
        const settings = await window.electronAPI.settings.getAll();

        // Load FPS and quality settings
        const savedFPS = settings.screen_recording_fps || '30';
        const savedQuality = settings.screen_recording_resolution || '1080p';

        // Load mic settings
        micEnabled = settings.region_mic_enabled === 'true';
        selectedMicId = settings.region_mic_device_id || null;

        // Load desktop audio setting
        desktopAudioEnabled = settings.region_desktop_audio_enabled === 'true';

        console.log('[RegionSelector] Loaded settings:', {
          fps: savedFPS,
          quality: savedQuality,
          micEnabled,
          selectedMicId,
          desktopAudioEnabled
        });

        // Apply to UI with fallback for legacy values
        const fpsSelect = document.getElementById('fpsSelect');
        const qualitySelect = document.getElementById('qualitySelect');
        const fpsOptions = Array.from(fpsSelect.options).map(option => option.value);
        const qualityOptions = Array.from(qualitySelect.options).map(option => option.value);
        const resolvedFPS = fpsOptions.includes(savedFPS) ? savedFPS : '30';
        const resolvedQuality = qualityOptions.includes(savedQuality) ? savedQuality : '1080p';

        fpsSelect.value = resolvedFPS;
        qualitySelect.value = resolvedQuality;
        document.getElementById('micToggle').classList.toggle('active', micEnabled);
        document.getElementById('audioToggle').classList.toggle('active', desktopAudioEnabled && hasBlackHole);

        // Set mic device if saved and available
        if (selectedMicId && audioDevices.length > 0) {
          const micSelect = document.getElementById('micSelect');
          const deviceExists = Array.from(micSelect.options).some(opt => opt.value === selectedMicId);
          if (deviceExists) {
            micSelect.value = selectedMicId;
            console.log('[RegionSelector] Restored saved microphone:', selectedMicId);
          } else {
            console.log('[RegionSelector] Saved microphone not found, resetting');
            selectedMicId = null;
          }
        }

        // Start monitoring if mic was previously enabled
        if (micEnabled && selectedMicId) {
          console.log('[RegionSelector] Auto-starting monitoring from saved settings');
          setTimeout(() => {
            startMicrophoneMonitoring();
          }, 500);  // Small delay to ensure UI is ready
        }
      } catch (error) {
        console.error('[RegionSelector] Failed to load settings:', error);
        // Use defaults on error
      }
    }

    // Listen for display info
    window.electronAPI?.region?.onDisplayInfo(async (info) => {
      console.log('[RegionSelector] Received display info:', info);
      displayInfo = info;
      // Load audio devices first, then load saved settings
      await loadAudioDevices();
      await loadSettings();
    });

    // Parse displayId from URL query parameter
    const urlParams = new URLSearchParams(window.location.search);
    currentDisplayId = urlParams.get('displayId');
    console.log('[RegionSelector] Overlay initialized for display:', currentDisplayId);

    // Mouse down - start drawing
    document.body.addEventListener('mousedown', (e) => {
      console.log('[RegionSelector] Mouse down:', e.clientX, e.clientY);
      isDrawing = true;
      startX = e.clientX;
      startY = e.clientY;

      // Hide instructions, button, and control panel
      instructions.style.display = 'none';
      startButton.style.display = 'none';
      controlPanel.style.display = 'none';

      // Reset rectangle
      rectangleEl.style.display = 'block';
      rectangleEl.style.left = startX + 'px';
      rectangleEl.style.top = startY + 'px';
      rectangleEl.style.width = '0px';
      rectangleEl.style.height = '0px';

      rect = { x: startX, y: startY, width: 0, height: 0 };
    });

    // Mouse move - update rectangle
    document.body.addEventListener('mousemove', (e) => {
      if (!isDrawing) return;

      const currentX = e.clientX;
      const currentY = e.clientY;

      const width = Math.abs(currentX - startX);
      const height = Math.abs(currentY - startY);
      const left = Math.min(startX, currentX);
      const top = Math.min(startY, currentY);

      rectangleEl.style.left = left + 'px';
      rectangleEl.style.top = top + 'px';
      rectangleEl.style.width = width + 'px';
      rectangleEl.style.height = height + 'px';

      // Update dimensions display
      dimensionsEl.textContent = `${Math.round(width)} × ${Math.round(height)}`;
      dimensionsEl.style.display = 'block';
      dimensionsEl.style.left = (left + width / 2) + 'px';
      dimensionsEl.style.top = (top - 35) + 'px';
      dimensionsEl.style.transform = 'translateX(-50%)';

      rect = { x: left, y: top, width, height };
    });

    // Mouse up - finish drawing
    document.body.addEventListener('mouseup', (e) => {
      if (!isDrawing) return;

      console.log('[RegionSelector] Mouse up, rectangle:', rect);
      isDrawing = false;

      // Show control panel and start button if rectangle is big enough
      if (rect && rect.width > 20 && rect.height > 20) {
        console.log('[RegionSelector] Rectangle is big enough, showing control panel');

        // Position and show control panel (button is inside panel)
        positionControlPanel();

        console.log('[RegionSelector] Control panel shown');
      } else {
        // Rectangle too small, reset
        rectangleEl.style.display = 'none';
        dimensionsEl.style.display = 'none';
        controlPanel.style.display = 'none';
        instructions.style.display = 'block';
        rect = null;
      }
    });

    // Start Recording button
    console.log('[RegionSelector] Setting up Start Recording button listener');
    console.log('[RegionSelector] startButton element:', startButton);

    // Prevent button from triggering drawing behavior
    startButton.addEventListener('mousedown', (e) => {
      e.stopPropagation();
      console.log('[RegionSelector] Button mousedown - prevented propagation');
    });

    startButton.addEventListener('mouseup', (e) => {
      e.stopPropagation();
      console.log('[RegionSelector] Button mouseup - prevented propagation');
    });

    startButton.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent body from receiving the click
      console.log('[RegionSelector] ===== START BUTTON CLICKED =====');
      console.log('[RegionSelector] rect:', rect);
      console.log('[RegionSelector] displayInfo:', displayInfo);

      if (!rect || !displayInfo) {
        console.error('[RegionSelector] Missing rect or displayInfo');
        return;
      }

      // Get current quality and FPS settings
      const quality = document.getElementById('qualitySelect').value;
      const fps = parseInt(document.getElementById('fpsSelect').value);

      const captureArea = {
        x: rect.x,
        y: rect.y,
        width: rect.width,
        height: rect.height,
        displayId: displayInfo.id,
        selectedFromDisplayId: currentDisplayId, // NEW: which overlay was used for selection
        scaleFactor: displayInfo.scaleFactor,
        displayBounds: displayInfo.bounds,
        // Add audio settings (Phase 2)
        audioSettings: {
          microphoneEnabled: micEnabled,
          microphoneDeviceId: selectedMicId || undefined,
          desktopAudioEnabled: desktopAudioEnabled
        },
        // Add quality settings
        quality: quality,
        fps: fps
      };

      console.log('[RegionSelector] Starting recording with capture area:', captureArea);
      console.log('[RegionSelector] Audio settings:', {
        mic: micEnabled,
        device: selectedMicId,
        desktop: desktopAudioEnabled
      });
      console.log('[RegionSelector] Quality settings:', { quality, fps });

      // Stop monitoring before starting recording
      console.log('[RegionSelector] Stopping monitoring before recording');
      stopMicrophoneMonitoring();

      // Send region data to start recording
      window.electronAPI.region.sendRegion(captureArea);

      // Switch to recording mode
      isRecording = true;
      startButton.style.display = 'none';
      controlPanel.style.display = 'none'; // Hide control panel during recording

      // Make overlay invisible and enable click-through
      document.body.style.background = 'transparent';
      document.body.style.backdropFilter = 'none';
      document.body.style.webkitBackdropFilter = 'none';

      // Update rectangle to thin border (CleanShot X style)
      rectangleEl.style.border = '1.5px solid rgba(59, 130, 246, 0.8)';
      rectangleEl.style.background = 'transparent';

      // Hide old standalone stop button
      stopButton.style.display = 'none';

      // Show new recording controls (duration + pause/stop buttons)
      recordingControls.style.display = 'flex';
      recordingControls.style.left = (rect.x + rect.width / 2) + 'px';
      recordingControls.style.top = (rect.y + rect.height + 20) + 'px';
      recordingControls.style.transform = 'translateX(-50%)';

      // Show recording indicator (positioned above rectangle, outside recording area)
      recordingIndicator.style.display = 'block';
      recordingIndicator.style.left = (rect.x + 10) + 'px';
      recordingIndicator.style.top = (rect.y - 40) + 'px'; // Above rectangle to avoid showing in video

      // Disable drawing during recording
      document.body.style.cursor = 'default';

      // Enable click-through after small delay (let UI update first)
      setTimeout(() => {
        console.log('[RegionSelector] Enabling click-through mode');
        window.electronAPI.region.setClickThrough(true);
        clickThroughEnabled = true;
      }, 100);

      console.log('[RegionSelector] Switched to recording mode');
    });

    // Stop Recording button
    stopButton.addEventListener('mousedown', (e) => {
      e.stopPropagation();
    });

    stopButton.addEventListener('mouseup', (e) => {
      e.stopPropagation();
    });

    stopButton.addEventListener('click', (e) => {
      e.stopPropagation();
      console.log('[RegionSelector] ===== STOP BUTTON CLICKED =====');

      // Send stop recording signal to main process
      console.log('[RegionSelector] Sending stopRecording event to main process');
      window.electronAPI.region.stopRecording();

      console.log('[RegionSelector] Stop recording event sent');
    });

    // Listen for duration updates from React
    window.electronAPI.region.onDurationUpdate((duration) => {
      durationDisplay.textContent = formatDuration(duration);
    });

    // Duration mark IPC listeners

    // Listen for marking state updates from React
    window.electronAPI.region.onMarkStateUpdate((marking, startTime) => {
      isMarking = marking;
      markStartTime = startTime || 0;

      if (marking) {
        console.log('[RegionSelector] Started marking at', startTime);
        updateMarkingIndicator(markStartTime);
        showMarkInput();
      } else {
        hideMarkInput();
      }
    });

    // Listen for note updates from React modal
    window.electronAPI.region.onMarkNoteUpdate((note) => {
      // Don't log every keystroke - too noisy
      markNoteText = note;
      const noteInput = document.getElementById('markNoteInput');
      if (noteInput && document.activeElement !== noteInput) {
        // Only update if not currently typing
        noteInput.value = note;
      }
    });

    // Listen for pause state updates from React modal
    window.electronAPI.region.onPauseStateUpdate((paused) => {
      console.log('[RegionSelector] Pause state update received from modal:', paused);

      // Update local state
      isPaused = paused;

      // Update pause button UI
      pauseButton.textContent = paused ? '▶' : '⏸';

      // Update recording indicator
      if (paused) {
        recordingIndicator.textContent = 'Paused';
        recordingIndicator.style.background = 'rgba(234, 179, 8, 0.9)';
      } else {
        recordingIndicator.textContent = 'Recording';
        recordingIndicator.style.background = 'rgba(220, 38, 38, 0.9)';
      }

      console.log('[RegionSelector] Overlay UI updated to reflect pause state:', paused);
    });

    // Listen for cmd+h input field toggle
    window.electronAPI.region.onInputFieldToggle(() => {
      if (!isRecording) return;

      // Don't send mark toggle back to React - the React modal already handles it!
      // The overlay will receive the marking state update and show/hide the input field
      console.log('[RegionSelector] Cmd+H pressed - waiting for marking state from React');
    });

    // Mark note input change handler
    const markNoteInputEl = document.getElementById('markNoteInput');
    if (markNoteInputEl) {
      // Fallback: Ensure focus when clicking input
      markNoteInputEl.addEventListener('click', () => {
        if (document.activeElement !== markNoteInputEl) {
          console.log('[RegionSelector] Click fallback - re-lowering window level');
          window.electronAPI.region.setWindowLevel('floating');
          setTimeout(() => markNoteInputEl.focus(), 50);
        }
      });

      markNoteInputEl.addEventListener('input', (e) => {
        markNoteText = e.target.value;
        // Don't log every keystroke - too noisy
        window.electronAPI.region.sendMarkNote(markNoteText);
      });

      // Listen for Enter key on the input field to finalize mark
      markNoteInputEl.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && isRecording) {
          e.preventDefault();
          e.stopPropagation(); // Prevent document listener from also firing
          console.log('[RegionSelector] Enter pressed in input field - finalizing mark');

          // Send the mark toggle to end the marking
          window.electronAPI.region.sendMarkToggle();
        }
      });
    }

    // Pause button handler
    pauseButton.addEventListener('click', (e) => {
      e.stopPropagation();
      console.log('[RegionSelector] Pause button clicked, current isPaused:', isPaused);

      if (isPaused) {
        // Resume recording
        console.log('[RegionSelector] Calling resumeRecording()');
        window.electronAPI.region.resumeRecording();
        pauseButton.textContent = '⏸';
        isPaused = false;

        // Update recording indicator back to red "Recording"
        recordingIndicator.textContent = 'Recording';
        recordingIndicator.style.background = 'rgba(220, 38, 38, 0.9)';
      } else {
        // Pause recording
        console.log('[RegionSelector] Calling pauseRecording()');
        window.electronAPI.region.pauseRecording();
        pauseButton.textContent = '▶';
        isPaused = true;

        // Update recording indicator to yellow "Paused"
        recordingIndicator.textContent = 'Paused';
        recordingIndicator.style.background = 'rgba(234, 179, 8, 0.9)';
      }
    });

    // Stop button (new) handler
    stopButtonNew.addEventListener('click', (e) => {
      e.stopPropagation();
      window.electronAPI.region.stopRecording();
    });

    // Prevent propagation for new buttons
    [pauseButton, stopButtonNew].forEach(btn => {
      btn.addEventListener('mousedown', (e) => e.stopPropagation());
      btn.addEventListener('mouseup', (e) => e.stopPropagation());
    });

    // ESC key to cancel, Enter key for duration marks
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        console.log('[RegionSelector] ESC pressed, canceling and cleaning up monitoring');

        // Restore window level if marking (to prevent stuck at floating level)
        if (isMarking) {
          console.log('[RegionSelector] Restoring window level to screen-saver before cancel');
          window.electronAPI.region.setWindowLevel('screen-saver');
        }

        stopMicrophoneMonitoring();
        window.electronAPI.region.cancel();
      } else if (e.key === 'Enter' && isRecording) {
        // ✅ FIX: Only fire if input field is NOT focused
        const markNoteInputEl = document.getElementById('markNoteInput');
        if (document.activeElement !== markNoteInputEl) {
          e.preventDefault();
          console.log('[RegionSelector] Enter pressed (document-level), toggling mark');
          window.electronAPI.region.sendMarkToggle();
        } else {
          console.log('[RegionSelector] Enter pressed in input field - handled by input listener');
        }
      }
    });

    // Cleanup monitoring when page unloads
    window.addEventListener('beforeunload', () => {
      console.log('[RegionSelector] Page unloading, cleaning up monitoring');
      stopMicrophoneMonitoring();
    });

    // Control Panel Click Handlers (Phase 1 - Basic Setup)

    // Prevent control panel from triggering drawing
    controlPanel.addEventListener('mousedown', (e) => {
      e.stopPropagation();
    });

    controlPanel.addEventListener('mouseup', (e) => {
      e.stopPropagation();
    });

    // Microphone toggle button
    document.getElementById('micToggle').addEventListener('click', async (e) => {
      e.stopPropagation();
      const button = e.currentTarget;

      // Check if disabled (permission denied)
      if (button.classList.contains('disabled')) {
        console.log('[RegionSelector] Microphone disabled (permission denied)');
        return;
      }

      micEnabled = !micEnabled;
      button.classList.toggle('active', micEnabled);

      // Save mic enabled state (Phase 6)
      try {
        await window.electronAPI.settings.set('region_mic_enabled', micEnabled ? 'true' : 'false');
        console.log('[RegionSelector] Saved mic enabled:', micEnabled);
      } catch (error) {
        console.error('[RegionSelector] Failed to save mic enabled:', error);
      }

      if (micEnabled && !selectedMicId) {
        // Auto-select first device
        const micSelect = document.getElementById('micSelect');
        if (micSelect.options.length > 1) {
          selectedMicId = micSelect.options[1].value;
          micSelect.value = selectedMicId;
          console.log('[RegionSelector] Auto-selected first microphone:', selectedMicId);
          // Save the auto-selected device
          try {
            await window.electronAPI.settings.set('region_mic_device_id', selectedMicId);
          } catch (error) {
            console.error('[RegionSelector] Failed to save mic device:', error);
          }
        }
      }

      // Start or stop monitoring based on mic state
      if (micEnabled) {
        if (selectedMicId) {
          startMicrophoneMonitoring();
        }
      } else {
        stopMicrophoneMonitoring();
      }

      console.log('[RegionSelector] Microphone enabled:', micEnabled);
    });

    // Microphone select
    document.getElementById('micSelect').addEventListener('change', async (e) => {
      e.stopPropagation();
      selectedMicId = e.target.value;
      console.log('[RegionSelector] Microphone selected:', selectedMicId);

      // Save mic device selection (Phase 6)
      try {
        await window.electronAPI.settings.set('region_mic_device_id', selectedMicId);
        console.log('[RegionSelector] Saved mic device:', selectedMicId);
      } catch (error) {
        console.error('[RegionSelector] Failed to save mic device:', error);
      }

      if (selectedMicId && !micEnabled) {
        // Auto-enable microphone when device selected
        micEnabled = true;
        document.getElementById('micToggle').classList.add('active');
        console.log('[RegionSelector] Microphone auto-enabled via device selection');
        // Save the auto-enabled state
        try {
          await window.electronAPI.settings.set('region_mic_enabled', 'true');
        } catch (error) {
          console.error('[RegionSelector] Failed to save mic enabled:', error);
        }
      }

      // Restart monitoring with new device
      if (micEnabled && selectedMicId) {
        stopMicrophoneMonitoring();  // Stop old monitoring
        setTimeout(() => {
          startMicrophoneMonitoring();  // Start with new device
        }, 100);  // Small delay for cleanup
      }
    });

    // Desktop audio toggle button
    document.getElementById('audioToggle').addEventListener('click', async (e) => {
      e.stopPropagation();
      const button = e.currentTarget;
      if (button.classList.contains('disabled')) {
        console.log('[RegionSelector] Desktop audio disabled (BlackHole not detected)');
        return;
      }
      button.classList.toggle('active');
      desktopAudioEnabled = !desktopAudioEnabled;
      console.log('[RegionSelector] Desktop audio enabled:', desktopAudioEnabled);

      // Save desktop audio state (Phase 6)
      try {
        await window.electronAPI.settings.set('region_desktop_audio_enabled', desktopAudioEnabled ? 'true' : 'false');
        console.log('[RegionSelector] Saved desktop audio enabled:', desktopAudioEnabled);
      } catch (error) {
        console.error('[RegionSelector] Failed to save desktop audio enabled:', error);
      }
    });

    // Quality select
    document.getElementById('qualitySelect').addEventListener('change', async (e) => {
      e.stopPropagation();
      const quality = e.target.value;
      console.log('[RegionSelector] Quality selected:', quality);

      // Save quality setting (Phase 6)
      try {
        await window.electronAPI.settings.set('screen_recording_resolution', quality);
        console.log('[RegionSelector] Saved quality:', quality);
      } catch (error) {
        console.error('[RegionSelector] Failed to save quality:', error);
      }
    });

    // FPS select
    document.getElementById('fpsSelect').addEventListener('change', async (e) => {
      e.stopPropagation();
      const fps = e.target.value;
      console.log('[RegionSelector] FPS selected:', fps);

      // Save FPS setting (Phase 6)
      try {
        await window.electronAPI.settings.set('screen_recording_fps', fps);
        console.log('[RegionSelector] Saved FPS:', fps);
      } catch (error) {
        console.error('[RegionSelector] Failed to save FPS:', error);
      }
    });

    // Mouse position tracking for button hover detection (active only during recording)
    document.addEventListener('mousemove', (e) => {
      if (!isRecording || !clickThroughEnabled) return;

      // Get bounds for entire recording controls container
      const controlsBounds = recordingControls.getBoundingClientRect();

      // Check if mouse is over controls
      const isOverControls = (
        e.clientX >= controlsBounds.left &&
        e.clientX <= controlsBounds.right &&
        e.clientY >= controlsBounds.top &&
        e.clientY <= controlsBounds.bottom
      );

      // Check if mouse is over duration mark input field
      const inputFieldEl = document.getElementById('durationMarkInput');
      const inputFieldBounds = inputFieldEl?.getBoundingClientRect();
      const isOverInputField = inputFieldBounds && (
        e.clientX >= inputFieldBounds.left &&
        e.clientX <= inputFieldBounds.right &&
        e.clientY >= inputFieldBounds.top &&
        e.clientY <= inputFieldBounds.bottom
      );

      // Toggle click-through: disable when over controls OR input field, enable otherwise
      window.electronAPI.region.setClickThrough(!isOverControls && !isOverInputField);
    });

    // Debug: Log ALL clicks
    document.addEventListener('click', (e) => {
      console.log('[RegionSelector] ===== CLICK DETECTED =====');
      console.log('[RegionSelector] Click target:', e.target);
      console.log('[RegionSelector] Click target ID:', e.target.id);
      console.log('[RegionSelector] Click target tagName:', e.target.tagName);
      console.log('[RegionSelector] Click coordinates:', e.clientX, e.clientY);
    }, true); // Use capture phase to ensure we catch it

    console.log('[RegionSelector] Event listeners registered');
  </script>
</body>
</html>
